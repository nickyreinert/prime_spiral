<!DOCTYPE html>
<!-- https://en.wikipedia.org/wiki/Ulam_spiral -->
<html>
  <head>
    <meta charset="utf-8">
    <title>Prime-Spiral</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #fff;
      }
      #container {
        position: relative;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;

      }

      .section_separator  {
        background-color: #e0e0e0;
      }

      .section_content:hover, .section_content td:hover  {
        background-color: #f0b0f0;
      }

      .settings_container {

        margin: 10px;
        margin-bottom: 30px;
        
      }

      .controller_container {
        width: auto;
        height: 100%;
        overflow: auto;
        position: fixed;
        z-index: 1000;
        background-color: #fff;
      }

    </style>
  </head>
  <body>
    
    <div id="controller_container" class="controller_container">
        <!-- <input type="button" id="audio" value="audio" onClick="enableAudio();" /> -->
        <input type="button" id="reset" value="Reset" onClick="resetParameters();" />
        <input type="button" id="export" value="Export" onClick="exportParameters();" />
        <input type="button" id="hide" value="Hide (Enter)" onClick="showHideControls();" />
        <label for="animate">Animate (Esc)</label>
        <input type="checkbox" id="animate" />
        <input type="range" min=25 max=100 step=25 value=75 id="overlay_alpha" onClick="adjustOverlayAlpha();" />
        <a href="https://github.com/nickyreinert/prime_spiral" id="doc" target="_blank">Source & Documentation</a>
        <i id="cpu_usage"></i>
        <table class="settings_container" id="config_container"></table>    
        <table class="settings_container" id="parameters_container"></table>    
    </div>    

    <div id="container">
        <canvas id="canvas" width="500" height="500"></canvas>
    </div>

    <script>

    function adjustOverlayAlpha() {

        let controller_container = document.querySelector('.controller_container');

        controller_container.style.opacity = document.querySelector('#overlay_alpha').value / 100;

    }
    
    function resetParameters() {
        
        document.querySelectorAll('.settings_container').remove();
        var parameters_container = document.createElement('table');
        parameters_container.id = 'parameters_container';
        parameters_container.className = 'settings_container';
        document.getElementById('controller_container').appendChild(parameters_container);

        var config_container = document.createElement('table');
        config_container.id = 'config_container';
        config_container.className = 'config_container';
        document.getElementById('controller_container').appendChild(config_container);

        window.parameters = JSON.parse(JSON.stringify(default_parameters));
        window.config = JSON.parse(JSON.stringify(default_config));

        document.location.search = '';

        saveSettingsToCookie();

        
        registerParameterControls();
        
        controlAnimation();
        
    }

    function importParameters() {

        let settings = document.location.search;

        try {

            settings = JSON.parse(atob((settings.substring(1))));

            parameters = settings.parameters;
            config = settings.config;

            if (parameters == undefined || config == undefined) {

                throw 'no parameters or config found';

            }

        } catch (e) {

            return settings_received;

        }
        
        settings_received = true;

        window.parameters = parameters;
        window.config = config;

        return settings_received;

    }

    function exportParameters() {
        
        // encrypt to URL
        document.location.search = '?' +  (btoa(JSON.stringify({config: config, parameters: parameters})));

    }

    function getCookie(name) {
        
        if (document.cookie.length > 0) {
            c_start = document.cookie.indexOf(name + '=');
            if (c_start!=-1) {

                c_start = c_start + name.length + 1;
                c_end = document.cookie.indexOf(';', c_start);
                
                if (c_end == -1) {c_end = document.cookie.length;}
                
                return unescape(document.cookie.substring(c_start,c_end));

            }
        }

        return "";
    }

    function saveSettingsToCookie() {

        // save everything to the cookie, for next reload
        let date = new Date();
        date.setTime(date.getTime() + (365 * 24 * 60 * 60 * 1000));
        const expires = "expires=" + date.toUTCString();

        document.cookie = 'config=' + escape(JSON.stringify(window.config)) + ';' + expires;
        document.cookie = 'parameters=' + escape(JSON.stringify(window.parameters)) + '; ' + expires;

    }

    function restoreParameters() {

        let parameters_cookie = getCookie('parameters');
        let config_cookie = getCookie('config');

        try {

            parameters = JSON.parse(parameters_cookie);
            config = JSON.parse(config_cookie);

        if (parameters == undefined || config == undefined) {

                throw 'no parameters or config found';

            }

        } catch (e) {

            return false;

        }
        
        window.parameters = parameters;
        window.config = config;

        return true;

    }

    function addControlElements() {

        addConfigControls();

        addParameterControls();

    }

    function addConfigControls() {
        
        current_section = '';
        current_group = '';

        for (const [key, value] of Object.entries(config)) {

            // add a new table row if its a new config-section
            if (value.section != current_section) {

                var separator = document.createElement('tr');
                separator.className = 'section_separator';
                separator.innerHTML = '<td colspan=7>' + value.section + '</td>';
                document.getElementById('config_container').appendChild(separator);
                var container = document.createElement('tr');
                container.className = 'section_content';
                container.innerHTML = '';
            
            // same section
            } else {
                
                // but new group? add a new row
                if (value.group != current_group) {
                    
                    var container = document.createElement('tr');
                    container.className = 'section_content';
                    container.innerHTML = '';

                }
                
            }
            
            // checkbox
            if (value.value === true || value.value === false) {
                
                if (value.value == true) {var checked = 'checked'} else {var checked = ''};

                container.innerHTML += 
                    '<td><label " for="' + key + '" />' + value.descr + '</label></td>' + 
                    '<td><input key="' + key + '" type="checkbox" size=3 ' + checked + ' " id="value_' + key + '" /></td>';

            // radio
            } else if (Array.isArray(value.value)) {

                container.innerHTML +=
                    '<td><label " for="' + key + '" />' + value.descr + '</label></td>'; 

                radios = '<td>';

                for (const item of value.value) {
                    
                    if (item == value.selected) {checked = 'checked'} else {checked = ''}

                    radios +=
                        '<input key="' + key + '" ' + checked + ' type="radio" size=8 value="' + item + '" name="' + key + '" id="value_' + key + '_' + item + '">' + item + '</input>';

                }

                radios += '</td>';

                container.innerHTML += radios;

            } else {

                container.innerHTML +=
                    '<td><label " for="' + key + '" />' + value.descr + '</label></td>' + 
                    '<td><input key="' + key + '" type="text" size=8 value="' + value.value + '" id="value_' + key + '" /></td>';

            }

            current_section = value.section;
            current_group = value.group;

            document.getElementById('config_container').appendChild(container);

        }

        // document.getElementById('config_container').innerHTML += '<tr class="section_separator"><td colspan=7></td></tr>';

    }
    
    function addParameterControls() {


        var container = document.createElement('tr');
        container.innerHTML  = '<td>Param</td>';
        container.innerHTML += '<td>Value</td>';
        container.innerHTML += '<td>Range</td>';
        container.innerHTML += '<td>Anim</td>';
        container.innerHTML += '<td>Min</td>';
        container.innerHTML += '<td>Max</td>';
        container.innerHTML += '<td>Steps</td>';

        document.getElementById('parameters_container').appendChild(container);

        for (const [key, value] of Object.entries(window.parameters)) {

            var container = document.createElement('tr');
            container.className = 'section_content';

            if (value.animate == true) {var checked = 'checked'; animated_parameters += 1;} else {var checked = ''};
            container.innerHTML = '<td>' + value.descr + ': </td>' +
                '<td><input type="text" size=3 value="' + value.value + '" id="value_' + key + '" /></td>' +
                '<td><input id="slider_' + key + '" ' +
                    'type="range" ' +
                    'min="' + value.min + '" ' +
                    'max="' + value.max + '" ' +
                    'step="' + value.step + '" ' +
                    'defaultValue="' + value.value + '" ' +
                    'value="' + value.value + '"/></td>' +
                '<td><input type="checkbox" ' +'id="animate_' + key + '" ' + checked + '/></td>' +
                '<td><input type="text" size=4 value="' + value.min + '" id="min_' + key + '" /></td>' +
                '<td><input type="text" size=4 value="' + value.max + '" id="max_' + key + '" /></td>' +
                '<td><input type="text" size=4 value="' + value.step + '" id="step_' + key + '" /></td>';
            
            document.getElementById('parameters_container').appendChild(container);

        }
    }
    
    function registerParameterControls() {

        // register on click events for the config controls
        for (const [key, value] of Object.entries(config)) {

            // if its a checkbox
            if (value.value === true ||value.value === false) {

                document.querySelector('#value_' + key).onclick = function(event) {
                    
                    let current_key = event.target.getAttribute('key');
                    
                    window.config[current_key]['value'] = event.target.checked;
                    
                    saveSettingsToCookie();

                    controlAnimation();

                }

            // if its a radio button
            } else if (Array.isArray(value.value)) {

                for (const item of value.value) {
                    
                    document.querySelector('#value_' + key + '_' + item).onclick = function(event) {
                        
                        let current_key = event.target.getAttribute('key');
                        
                        window.config[current_key]['selected'] = event.target.value;
                        
                        saveSettingsToCookie();

                        controlAnimation();
                        
                    }
                }

            // if its a text input
            } else {

                document.querySelector('#value_' + key).addEventListener('input', (event) => {

                    let current_key = event.target.getAttribute('key');
                    
                    window.config[current_key]['value'] = event.target.value;

                    saveSettingsToCookie();

                    controlAnimation();

                })
            
            }
                
        }

        for (const [key, value] of Object.entries(parameters)) {

            const controls = ['slider', 'min', 'max', 'step', 'value', 'animate'];

            for (const control of controls) {

                let current_control = document.querySelector('#' + control + '_' + key);

                if (control == 'animate') {

                    current_control.onclick = function(event) {

                        // extract the parameter, setting (min, max, ...) and value
                        let parameter_and_setting = event.target.getAttribute('id');
                        let parameter = parameter_and_setting.split('_')[1];

                        if (event.target.checked) {

                            window.parameters[parameter]['animate'] = true;
                        
                            animated_parameters += 1;

                        } else {

                            window.parameters[parameter]['animate'] = false;

                            animated_parameters -= 1;

                        }

                        saveSettingsToCookie();

                        controlAnimation();

                    }


                } else {

                    current_control.addEventListener('input', (event) => {

                        // extract the parameter, setting (min, max, ...) and value
                        let parameter_and_setting = event.target.getAttribute('id');
                        let setting = parameter_and_setting.split('_')[0];
                        let parameter = parameter_and_setting.split('_')[1];
                        let value = event.target.value
                        
                        // the slider is the only one that also controls the "value" 
                        // of the current parameter
                        if (setting == 'slider') {
                        
                            // set the global parameter object
                            window.parameters[parameter]['value'] = value;
                            // set the value input field
                            document.querySelector('#value_' + parameter).value = value;

                        // if not the slider, then it's the value, min, max or step value
                        // which also impacts the slider
                        } else {

                            window.parameters[parameter][setting] = value;
                            let slider = document.querySelector('#slider_' + parameter);
                            slider[setting] = value;
                            // also check if the current value outreaches the current slider range
                            if (slider.max < slider.value) {
                                slider.value = slider.max;
                                window.parameters[parameter]['value'] = value;
                            } else if (slider.min > slider.value) {
                                slider.value = slider.min;
                                window.parameters[parameter]['value'] = value;
                            }

                        }
                        saveSettingsToCookie();

                        controlAnimation();

                   })

                } // curent_control != animate
            }
            
        }

    }

    function listenToScreenSizeChanges() {
      
        window.addEventListener("resize", function() {
            
            resizeCanvases();

            draw(parameters);

      });

    }
      
    function numberIsPrime(num) {
        
        if (num < 2) {return false;}

        if (primes.includes(num)) return true;

        for(let i = 2, s = Math.sqrt(num); i <= s; i++) {

            if (num % i  === 0) return false;
        
        }

        primes.push(num);

        return true;
    }
   
    function hexToRgb(hex) {
        // thanks to https://stackoverflow.com/a/5624139/2360229
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    // function enableAudio() {
  
    //     console.log('enable audio');
    //     var context = new AudioContext();
    //     o = context.createOscillator()
    //     g = context.createGain()
    //     o.type = 'triangle';
    //     o.connect(g)
    //     o.frequency.value = 87.31;
    //     g.connect(context.destination)
    //     o.start(0)

    //     g.gain.exponentialRampToValueAtTime(
    //         0.00001, context.currentTime + 1
    //     )

    // }

    function draw() {
                
        var start_time = performance.now();
    
        var screenWidth = window.innerWidth;
        var screenHeight = window.innerHeight;

        for (visual in visuals) {
            
            contexts[visuals[visual]].clearRect(0, 0, screenWidth, screenHeight);
    
        }
    
        // context_dots.globalAlpha = 0.5;

        num = 2;

        var centerx = contexts['lines'].canvas.width / 2;
        var centery = contexts['lines'].canvas.height / 2;

        contexts['lines'].moveTo(centerx, centery);
        contexts['lines'].beginPath();
        
        prime_fill_color_rgb = hexToRgb(config.prime_fill_color.value);
        prime_line_color_rgb = hexToRgb(config.prime_outline_color.value);
        
        contexts['dots'].lineWidth = 5;
        contexts['dots'].lineCap = "round";

        var coordinates = {x: 0, y: 0};

        var previous_x = 0, previous_y = 0;

        for (i = 0; i < parseInt(parameters.range.value); i++) {

            num = num + 1;

            coordinates = calculateXandY(centerx, centery, i);

            if (config.eco.value == true && (coordinates.x < 0  || coordinates.y < 0 || 
                coordinates.x > screenWidth || coordinates.y > screenHeight)) {
                
                contexts['lines'].moveTo(coordinates.x, coordinates.y);

                previous_x = coordinates.x;
                previous_y = coordinates.y;

                continue;

            }
            
            if (numberIsPrime(num)) {

                if (config.show_primes_arcs.value == true) {

                    drawArcs(coordinates.x, coordinates.y, contexts['dots'], num);

                }

                drawRays(coordinates.x, coordinates.y, centerx, centery, contexts['rays']);

                if (config.show_primes.value == true) {
                    contexts['lines'].fillText(num, x, y);
                }
                
            // not a prime, draw arcs and text
            } else {


                if (config.show_number_arcs.value == true) {

                    drawArcs(coordinates.x, coordinates.y, contexts['dots'], num);

                }

                if (config.show_numbers.value == true) {
                
                    contexts['lines'].fillText(num, coordinates.x + 5 , coordinates.y + 5);

                } 

            }

            if (config.show_beziers.value == true && i > 1) {
                
                contexts['lines'].bezierCurveTo(centerx, centery, previous_x, previous_y, coordinates.x, coordinates.y);

            } else {

                contexts['lines'].lineTo(coordinates.x, coordinates.y);

            }

            previous_x = coordinates.x;
            previous_y = coordinates.y;

            // context_lines.arc(x, y, 2, 0, 2 * Math.PI);
            // context_lines.fillText('angel: ' + parseInt(angle) + ', x: ' + parseInt(x) + ', y:' + parseInt(y), x, y);

        }

        // for (r = 0; r < 1; r++) {
        
        //     // r = raindrop index
        //     drawRainDrop(r, contexts['raindrops']);

        // }       

        if (config.general_fill_color.value.includes('#')) {
            contexts['lines'].fillStyle = config.general_fill_color.value;
            contexts['lines'].fill();
        }
        if (config.general_outline_color.value.includes('#')) {
            contexts['lines'].strokeStyle = config.general_outline_color.value;
            contexts['lines'].stroke();
        }

        reDrawContexts();

        document.getElementById('cpu_usage').innerHTML = 'Frame render time ' + Math.round(performance.now() - start_time) + 'ms';

    }

    function reDrawContexts() {

        var screenWidth = window.innerWidth;
        var screenHeight = window.innerHeight;

        var canvas_container = document.getElementById('canvas');

        var context_container = canvas_container.getContext('2d', { alpha: true});

        context_container.clearRect(0, 0, screenWidth, screenHeight);

        for (visual in visuals) {
            
            context_container.drawImage(canvases[visuals[visual]], 0, 0);
            
        }

    }

    function calculateAngle(angle_function, angle) {

        switch (angle_function) {
            case 'cos':
                return Math.cos(angle);
            case 'tan':
                return Math.tan(angle);
            case 'sin':
                return Math.sin(angle);
        }

    }

    function calculateXandY(centerx, centery, i) {

        
        // how to draw a circle:
        // var x = center_x + radius * distance * Math.cos(-angle*Math.PI/180);
        // how to draw a spiral:
        
        let angle = (parseFloat((parameters.smoother.value)) * i) + parseFloat(parameters.rotation.value);

        let slope = parseInt(parameters.a.value);
        let intercept = parseFloat(parameters.b.value);
        let diam = parseInt(parameters.diam.value)
        let x_angle = calculateAngle(config.x_angle.selected, angle * Math.PI/parameters.pidivisor.value);
        let y_angle = calculateAngle(config.y_angle.selected, angle * Math.PI/parameters.pidivisor.value);
        
        if (config.center.value == false) {

            centerx = 0;
            centery = 0;

        }
        if (config.distortion.value == true) {

            distortion = i;

        } else {

            distortion = 1;
        }

        if (config.power.value == true) {

            x_angle *= x_angle;
            y_angle *= y_angle;

        }

        x = centerx + (distortion * ((slope + intercept * angle) + diam) * x_angle);

        y = centery + (distortion * ((slope + intercept * angle) + diam) * y_angle);

        // floor coordinates to integers to improve performance according to https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas?retiredLocale=de
        // return {x: x, y: y};
        return {x: Math.floor(x), y: Math.floor(y)};

    }

    function drawRays(x, y, centerx, centery, context) {

        if (config.show_primes_rays.value == true) {

            context.lineWidth = parseInt(config.ray_width.value);
            context.strokeStyle = config.prime_outline_color.value;

            if (config.relative_line_width.value == true) {
                
                context.lineWidth = parseInt(config.ray_width.value) - parseInt(100 * i / parameters.range.value);
    
                if (config.fading_line.value == true) {

                    factor = Math.round((100 - Math.floor(100 * i / parameters.range.value))) / 100
                    context.strokeStyle = "rgba(" +
                        Math.floor(prime_line_color_rgb.r) + "," +
                        Math.floor(prime_line_color_rgb.g) + "," +
                        Math.floor(prime_line_color_rgb.b) + "," +
                        parseFloat(1 - factor) + 
                        ")";

                }
                    
            }
            
            context.beginPath();

            if (config.center.value == true) {
    
                context.moveTo(centerx, centery);
            
            } else {
    
                context.moveTo(0, 0);
    
            }
            
            context.lineTo(x, y);

            context.stroke();
        
        }

    }
    
    // function drawRainDrop(rainDropIndex, context) {

    //     if (typeof(rain_drops[rainDropIndex]) == 'undefined') {
            
    //         x = Math.floor(Math.random() * window.innerWidth);
    //         y = Math.floor(Math.random() * window.innerHeight);

    //         rain_drops[rainDropIndex] = {};

    //         rain_drops[rainDropIndex].x = x;
    //         rain_drops[rainDropIndex].y = y;
    //         rain_drops[rainDropIndex].r = 1;

    //     } else {

    //         x = rain_drops[rainDropIndex].x;
    //         y = rain_drops[rainDropIndex].y;
    //         r = rain_drops[rainDropIndex].r * 1.1;
    //         rain_drops[rainDropIndex].r = r;

    //     }

    //     context.arc(x, y, r, 0, 2 * Math.PI);
    //     context.stroke();
    //     console.log('------');
    //     console.log(rain_drops);

    // }

    function drawArcs(x, y, context_dots, num) {

        context_dots.beginPath();
        let scale_factor = 1;
        if (config.scale_diameter.value == true) {

            scale_factor = Math.pow((1 + (num / window.parameters.range.value)), 3);

        } else {

            scale_factor = 1;

        }

        // scale the size of the arc based on the distance to the center
        diameter = parseFloat(scale_factor * parameters.markerdiam.value);

        // set position
        context_dots.arc(x, y, diameter, 0, 2 * Math.PI);
        
        // fill the arc
        if (config.prime_fill_color.value.includes('#')) {

            if (config.fading_fill_color.value == true){
                factor = Math.round((100 - Math.floor(100 * i / parameters.range.value))) / 100
                context_dots.fillStyle = "rgba(" +
                    Math.floor(prime_fill_color_rgb.r) + "," +
                    Math.floor(prime_fill_color_rgb.g) + "," +
                    Math.floor(prime_fill_color_rgb.b) + "," +
                    parseFloat(factor) + 
                    ")";

            } else {

                context_dots.fillStyle = config.prime_fill_color.value;

            }
            
            context_dots.fill();

        }

        // draw outline
        if (config.prime_outline_color.value.includes('#')) {

            if (config.fading_fill_color.value == true){
                factor = Math.round((100 - Math.floor(100 * i / parameters.range.value))) / 100
                context_dots.strokeStyle = "rgba(" +
                    Math.floor(prime_line_color_rgb.r) + "," +
                    Math.floor(prime_line_color_rgb.g) + "," +
                    Math.floor(prime_line_color_rgb.b) + "," +
                    parseFloat(factor) + 
                    ")";

            } else {

                context_dots.strokeStyle = config.prime_outline_color.value;

            }
            context_dots.stroke();
            
        }

    }

    function controlAnimation() {
        
        if (document.querySelector('#animate').checked) {window.animation = true}

        if (window.animated_parameters <= 0) {window.animation = false}

        draw();
        if (typeof(loop) != 'undefined') {
                        
            window.clearInterval(loop);

        }

        if (window.animation == true) {
            
            // TODO: https://blog.webdevsimplified.com/2021-12/request-animation-frame/
            loop = setInterval(animateDrawing, parseInt(document.querySelector('#value_delay').value));

        }

    }

    function animateDrawing() {

        // used to count the precision of float values to round the result
        var decimals = 0;

        // if in animation mode, loop through all parameters
        for (const [key, attributes] of Object.entries(parameters)) {

            // check if the current parameter is set to be animated
            if (document.querySelector('#animate_' + key).checked) {

                // check if the current value needs to be incremented
                if (parameters[key]['direction'] == 'inc') {

                    // check if the current value is a float or an integer
                    if (parameters[key]['type'] == 'float') {

                        // get current precision
                        decimals = (parameters[key]['step'] + "").split('.')[1].length;

                        parameters[key]['value'] = (parseFloat(parameters[key]['value']) + parseFloat(parameters[key]['step'])).toFixed(decimals);

                    } else if (parameters[key]['type'] == 'int') {
                        parameters[key]['value'] = parseInt(parameters[key]['value']) + parseInt(parameters[key]['step']);
                    }
                    
                    // if parameter reached max value, change direction
                    if (parameters[key]['value'] > parameters[key]['max']) {

                        parameters[key]['direction'] = 'dec';

                    }
                
                // check if the current value needs to be incremented
                } else if (parameters[key]['direction'] == 'dec') {

                    // check if the current value is a float or an integer
                    if (parameters[key]['type'] == 'float') {

                        // get current precision
                        decimals = (parameters[key]['step'] + "").split('.')[1].length;

                        parameters[key]['value'] = (parseFloat(parameters[key]['value']) - parseFloat(parameters[key]['step'])).toFixed(decimals);
                    } else if (parameters[key]['type'] == 'int') {
                        parameters[key]['value'] = parseInt(parameters[key]['value']) - parseInt(parameters[key]['step']);
                    }
                    
                    // if parameter reached max value, change direction
                    if (parameters[key]['value'] < parameters[key]['min']) {
                        parameters[key]['direction'] = 'inc';
                    }
                }
                            
                // update the slider and the input field
                document.querySelector('#slider_' + key).value = parameters[key]['value'];
                document.querySelector('#value_' + key).value = parameters[key]['value'];

            }
            
        }
        
        draw();

    }

    function showHideControls() {

        let settings_container = document.querySelectorAll('.settings_container');

        settings_container.forEach(function(element) {
            if (element.style.display == 'none') {

                document.querySelector('#controller_container').style.height = '100%';
                element.style.display = 'block';

            } else {

                document.querySelector('#controller_container').style.height = 'auto';
                element.style.display = 'none';
            }
        });

    }

    function registerAnimationControlParameters() {
        
        let animate = document.querySelector('#animate');

        animate.onclick = function(event) {

            if (event.target.checked) {
                
                window.animation = true;

            } else {

                window.animation = false;

            }

            controlAnimation();

        }

        document.addEventListener('keydown', function(event) {

        if (event.key == 'Enter') {

            showHideControls();

        }

        if (event.key == 'Escape') {

            window.animation = !window.animation;

            let animate = document.querySelector('#animate');
            
            animate.checked = !animate.checked;

            controlAnimation();

        }

        });


    }

    function createCanvasesAndContexts() {

        var canvas_container = document.getElementById('canvas');

        var context_container = canvas_container.getContext('2d', { alpha: true});

        for (visual in visuals) {
            
            canvases[visuals[visual]] = document.createElement('canvas');
            contexts[visuals[visual]] = canvases[visuals[visual]].getContext('2d');
            
        }

    }

    function resizeCanvases() {

        var screenWidth = window.innerWidth;
        var screenHeight = window.innerHeight;

        document.getElementById('container').style.width = screenWidth + "px";
        document.getElementById('container').style.height = screenHeight + "px";

        var canvas_container = document.getElementById('canvas');

        canvas_container.style.width = screenWidth + 'px';
        canvas_container.style.height = screenHeight + 'px';
        canvas_container.width = screenWidth * parseInt(config.scale.value);
        canvas_container.height = screenHeight * parseInt(config.scale.value);

        for (visual in visuals) {
            
            canvases[visuals[visual]].width = screenWidth * parseInt(config.scale.value);
            canvases[visuals[visual]].height = screenHeight * parseInt(config.scale.value);

        }

    }

    var primes = [];

    var rain_drops = {};

    const animation = true;
    
    var animated_parameters = 0;

    // don't touch this, it's just a list representing the canvases
    var visuals = ['lines', 'rays', 'dots'];
    // init additional canvas layers
    var canvases = {};
    var contexts = {};

    const default_config = {
            'delay':                    {section: "Animation", group: "A", value: 10, descr: 'Delay'},
            'scale':                    {section: "Animation", group: "A", value: 1, descr: 'Resolution scale'},
            'eco':                      {section: "Animation", group: "A", value: false, descr: 'Do not draw outside the canvas'},
            'x_angle':                  {section: "Angular Functions", group: "A", value: ['cos', 'sin', 'tan'], selected: 'cos', descr: 'Calculate X angle by'},
            'y_angle':                  {section: "Angular Functions", group: "B", value: ['cos', 'sin', 'tan'], selected: 'sin', descr: 'Calculate Y angle by'},
            'center':                   {section: "Misc", group: "A", value: true, descr: 'Start at center'},
            'power':                    {section: "Misc", group: "A", value: false, descr: 'Power by 2 for angle calculation'},
            'distortion':               {section: "Misc", group: "A", value: false, descr: 'Activate distortion'},
            'show_numbers':             {section: "Numbers", group: "A", value: false, descr: 'Show numbers'},
            'show_primes':              {section: "Numbers", group: "A", value: false, descr: 'Show prime numbers'},
            'show_number_arcs':         {section: "Arcs", group: "A", value: false, descr: 'Show arcs around non-primes'},
            'show_primes_arcs':         {section: "Arcs", group: "A", value: true, descr: 'Show arcs around prime numbers'},
            'scale_diameter':           {section: "Arcs", group: "B", value: false, descr: 'Scale arc diameter'},
            'show_beziers':             {section: "Lines", group: "A", value: false, descr: 'Use bezier curves'},
            'show_primes_rays':         {section: "Lines", group: "B", value: false, descr: 'Prime rays from the center'},
            'ray_width':                {section: "Lines", group: "B", value: 100, descr: 'Prime rays width'},
            'relative_line_width':      {section: "Lines", group: "C", value: false, descr: 'Prime rays with relative width'},
            'fading_line':              {section: "Lines", group: "C", value: false, descr: 'Prime rays fade out'},
            'prime_outline_color':      {section: "Colors", group: "A", value: '#abcabc', descr: 'Prime arc outline color'},
            'prime_fill_color':         {section: "Colors", group: "A", value: '#defdef', descr: 'Prime arc fill color'},
            'general_outline_color':    {section: "Colors", group: "B", value: '#456456', descr: 'General outline color'},
            'general_fill_color':       {section: "Colors", group: "B", value: '', descr: 'General fill color'},
            'fading_fill_color':        {section: "Colors", group: "C", value: false, descr: 'Fade out arcs'}
        }
 
    // heads up, please do not use underscores for the attributes
    const default_parameters = {
        range:          {value: 360, min: 90, max: 1440 * 1, step: 1, descr: 'Range', type: 'int', animate: false, direction: 'inc'},
        smoother:       {value: 0.1, min: 0, max: 1, step: 0.0001, descr: 'Density', type: 'float', animate: false, direction: 'inc'},
        rotation:       {value: 0, min: -90, max: 90, step: 0.1, descr: 'Rotation', type: 'float', animate: false, direction: 'inc'},
        a:              {value: 100, min: 0, max: 5, step: 0.01, descr: 'Slope', type: 'float', animate: true, direction: 'inc'},
        b:              {value: 5, min: 0, max: 10, step: 0.01, descr: 'Intercept', type: 'float', animate: true, direction: 'inc'},
        pidivisor:      {value: 3.1428, min: 3.1428, max: 360, step: 3.1428, descr: 'divide PI by', type: 'float', animate: false, direction: 'inc'},
        diam:           {value: 180, min: 0, max: 360, step: 1, descr: 'Main Diameter', type: 'int', animate: true, direction: 'inc'},
        markerdiam:     {value: 3, min: 1, max: 100, step: 1, descr: 'Marker-Diameter', type: 'int', animate: false, direction: 'inc'}
    }

    // first try to read settings from cookie
    var settings_received = restoreParameters();

    // then try to read settings from URL
    settings_received = importParameters();
    

    if (typeof(settings_received) == 'undefined' || !settings_received) {

        parameters = JSON.parse(JSON.stringify(default_parameters));
        config = JSON.parse(JSON.stringify(default_config));

        saveSettingsToCookie();

    } 

    addControlElements();
    
    registerAnimationControlParameters();

    registerParameterControls();


    createCanvasesAndContexts();

    resizeCanvases();

    draw();

    listenToScreenSizeChanges();

    </script>
</body>